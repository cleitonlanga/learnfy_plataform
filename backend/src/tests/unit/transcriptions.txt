

[Segment 1 | start=0s]

Vamos bater um papo sobre feature flags e as utilidades de feature flags. Feature flags, explicado de maneira rápida e simplista até, é basicamente um if-else no seu código que vai executar algo caso uma flag esteja ativada. Você vai ter if user ponto e aí alguma feature flag. Podemos supor que o usuário foi migrado da v1 para v2. Então a gente tem aqui if user v2 enabled, alguma coisa vai ser executada e caso contrário, a gente vai executar a versão 1 do aplicativo. Não foge muito disso, o feature flag não é muito diferente de um if-else que checa se um usuário tem acesso a algo ou não. Claro, estou simplificando um pouco a implementação. Você pode ter isso no seu banco de dados, nada proíbe, mas geralmente as pessoas vão utilizar outro local para ter as feature flags. Uma opção muito comum é aqui o LaunchDarkly. Aí você tem aqui a SDK, enfim, você tem toda uma UI, um dashboard que você vai poder entrar e configurar flags para cada usuário, enfim. A questão é, esses atributos aqui vão viver em algum lugar, quer seja você que administre eles ou você terceiriza esse trabalho. A gente vai falar então das utilidades de Feature Flags, as várias utilidades que elas existem. Recentemente estive conversando com alguns empresários sobre coisas que eles fazem na empresa deles e algo que surgiu de interessante foi que vários deles veem Feature Flags como algo bastante positivo. Vamos falar disso. Antes disso, eu vou te falar do patrocínio desse vídeo. que é a Abacus AI. É o seguinte, a Abacus repaginou totalmente a IDE de código deles, agora a IDE deles utiliza do DeepAgent, e o que você está vendo na tela é eu interagindo com a IDE e ela criando um Tetris em tempo real, de maneira extremamente rápida. Eu pedi para a IDE criar um Tetris, ela abriu para mim um browser com um playground, que aí eu conseguiria ver de imediato o que estava acontecendo no código ali, e a gente tem, em menos de um minuto, um Tetris jogável. Esse ferramental é muito poderoso, tá? Você pode mexer nas suas codebases, você pode criar MVPs. Os benchmarks vencem praticamente todos os outros agentes de IA. Em alguns benchmarks vencem todos, inclusive. Esse ferramental, e todo o ferramental da Abacus, tá disponível por apenas 10 dólares por mês. Hoje isso dá uns 50 e poucos reais. É uma ferramenta que, em determinadas tarefas, pode aumentar muito a sua produtividade. Eu mostrei o exemplo do Tetris, que não existe um universo em que eu conseguiria fazer isso, esse resultado excelente, para algo simples, em um minuto. E depois eu poderia pegar o código, refatorar, colocar na minha codebase, subir para o meu GitHub e fazer o que eu quiser com isso. Enfim, isso e todo outro ferramental da Abacus que eu mostro aqui em vários vídeos, disponível na mesma subscription de apenas 10 dólares. Crie a sua conta no Abacus, o link está aqui na descrição. Bom, é claro, né, lembrando que a Abacus tem suporte a basicamente todos os modelos de ar. Você pode usar o GPT-5, o Cloud Sonnet 4.5 que acabou de sair. Todos os melhores modelos de ar estão embutidos nesse ecossistema. Então, sinceramente, não tem muito motivo pra você não usar. Ele inclui, de fato, todos os outros e você pode usar todos os modelos. É, sinceramente, atualmente é o único que eu tenho pagado, tá? Bom, feature flag é nosso if-else aqui, existem algumas utilidades de feature flags. Supondo que você esteja fazendo algo parecido com trunk-based development e você não utilize muito de branches ou de, enfim, variações muito grandes no seu código, a equipe trabalha mais com algo de entrega contínua e trunk-based. Dá um Google se você não souber o que é. Mas enfim, quando você trabalha com trunk-based development, a ideia é que você vai estar levando tudo para a main o mais rápido possível e isso significa que algumas coisas vão estar incompletas na main. E está tudo bem, porque essas coisas incompletas você pode esconder atrás de feature flags. Eu posso ter essa feature que não está completa escondida atrás de uma feature flag e disponibilizando aos poucos para alguns usuários. Essa é uma das utilizações de feature flags. Você consegue então esconder partes incompletas. Você pode também segmentar o comportamento para o usuário. Então, imagina que você tem um usuário que é premium e um que não é premium. O usuário que é premium pode ter acesso a algo que está escondido atrás de uma feature flag. Você pode ter beta testers, você pode ter admins, você pode ter, enfim, uma infinidade de coisas que vai definir o comportamento do seu software baseado na flag que o usuário tem. E você pode fazer algo muito interessante, que é testes AB. Essas são a maioria das utilidades de Feature Flags. E tem algo muito interessante, que é um conceito que muitas empresas utilizam, que é... Tem um artigo bastante popular da Meta, que eu acho que ele chama Massive Rollout at Massive Scale, algo assim. Se encontrar, eu deixo na descrição, tá? Que a ideia é o seguinte, a gente não consegue evitar bugs. Isso não existe. Bugs vão acontecer. É interessante, então, que eu não faça um rollout de bugs para 100% dos meus usuários. Conforme eu vou fazendo um rollout, conforme eu vou deployando coisas que podem conter bugs, é legal eu dar acesso primeiro para os funcionários da empresa. Então você vai ter que os funcionários vão ter acesso primeiro a uma funcionalidade mais experimental. Depois, 0% ou 1% da minha user base vai ter a feature flag ativada, vai ter aqui a segmentação AB para ter acesso a essa funcionalidade. E se o bug afetar essas pessoas, Possivelmente eu vou saber que esse bug aconteceu, eu vou ter um erro pingando ali no meu Sentry, pingando ali no meu Slack, ou eu vou ter usuários reclamando, e o erro não vai afetar a minha codebase inteira. Se esse erro causar uma perda financeira pra mim, vai ser uma perda financeira só sobre 0.1% da userbase, não de todos. Caso dê certo, Você faz um rollout para 10%, depois para 25% das pessoas, depois você pode mandar para a user base inteira e isso aqui garante que o seu risco está reduzido. Imagina o seguinte, imagina que você tem aqui a sua user base e você faz um commit da maneira tradicional que a gente geralmente faz. Comitei, deploiei um código, esse código, essa feature nova está disponível para 100% dos clientes. O que acontece? Se tiver um bug, 100% dos clientes vão enxergar esse bug. E se eu fizer isso? Imagina que a gente faça isso quatro vezes. Mande quatro features, cada uma dessas quatro features tinha um bug. Então, eu tinha quatro bugs, quatro deploys, cada user viu quatro bugs e acha agora que o meu software é uma porcaria. Todos eles viram todos os bugs, todos eles foram expostos a todos os problemas e eu não consegui reverter antes de afetar uma grande parte da user base. Se eu estiver testando uma feature mais experimental, imagina que eu faço o deploy assim, tá? Aqui eu testei quatro features, Cada segmento da minha codebase teve acesso a uma feature diferente. E todas elas estavam bugadas, imagina que todas elas estavam bugadas. Eu consigo feedback nas minhas quatro features, nos quatro bugs. A gente tem o mesmo número de bugs, só que agora cada user viu apenas um bug. Você não tem um único usuário que viu todos os 4 bugs. O seu software, de fato, teve mais valor para todos os usuários. Seu software causou menos perdas. Seu software afetou negativamente menos. E a gente consegue utilizar isso para testar um pouco mais agressivamente. Você consegue lançar features que não estão super bem polidas, sabe? Pô, de repente não sei se a EOX fica melhor dessa maneira ou dessa outra maneira, eu consigo lançar para alguns usuários e coletar algum tipo de feedback. De repente algum usuário que gosta mais de ser beta-tester, de testar coisas mais experimentais, pode aliviar um pouco o quanto você vai precisar testar e validar isso inteiramente. Porque, novamente, você nunca vai evitar 100% dos bugs. Eles vão acontecer, vai ter retrabalho, vai ter refaturação. é melhor que isso afete poucas pessoas e que a gente consiga pegar isso mais rapidamente. O bom também é que a feature flag, ao invés do deploy aqui, que eu deployei e o código está disponível para todo mundo, se eu lançar através de uma feature flag, eu tenho uma kill switch, eu tenho um circuit breaker, algo que eu consigo desligar, porque eu lancei essa feature flag certo para esses usuários aqui, a minha feature está escondida, atrás de uma feature flag para esses usuários, se começar a pingar erros ali no meu Sentry, eu não preciso de um deploy novo para desativar isso. Eu vou lá na minha ferramenta de feature flags e desativo a feature flag e pronto, está limpo. Nenhum deploy adicional, nenhum segundo a mais demorou, todos os usuários têm a feature flag desativada agora. Isso é extremamente poderoso. E pode parecer, né, pô, mas isso aí não é meio gambiarra de empresa pequena? Não. Todas as empresas grandes estão fazendo isso de uma maneira ou de outra, tá? A gente tem exemplos públicos e notórios disso, como, por exemplo, o autoplay da Netflix. Você acha que a Netflix decidiu um dia, não, vamos rolar aqui autoplay pra todos os usuários. Agora, a partir do dia de hoje, todo mundo vai ter o vídeo passando automaticamente quando você entra na netflix.com. Claro que não. Eles testaram isso com alguns usuários, eles fizeram um teste AB e não necessariamente tá... Aqui a gente tá saindo um pouco de feature flag e a gente tá entrando num ferramental de teste AB que é um pouco mais complexo e completo que feature flag, mas a ideia ainda é parecida, tá? Eles utilizaram de teste AB e eles viram que, infelizmente, aparentemente, os usuários preferem autoplay. Não é que eles preferem, né? É que autoplay gerava mais tempo dentro da plataforma e era isso que eles estavam otimizando, enfim. O legal de feature flag é que ela vai fazer uma separação, eu falei de trunk-based development, ela vai fazer uma separação entre deploy e release. Na maioria das empresas que eu trabalhei, deploy e release eram sinônimos, mas não necessariamente precisa ser. Você pode deployar o código tranquilamente, esconder a nova funcionalidade ou o que quer que seja atrás de uma feature flag, e quando você quiser, você pode lançar essa feature flag. habilitando o comportamento para todos os usuários, se você quiser lançar para todos. Como separa deploy de release, a gente consegue atingir o nosso objetivo de continuous integration, integração contínua. Essas são as utilidades de Feature Flags. Os pontos positivos de Feature Flags são aquilo que eu falei, você vai conseguir testar com menos impacto, você consegue integração mais contínua, você consegue redução de risco. Isso vai te dar mais conforto em lançar e experimentar com coisas novas, vai te possibilizar ter mais inovação, mais agilidade. São pontos excelentes, mas existem também algumas contras partidas de Feature Flags, tá? Feature Flags, elas têm que ser, assim, podadas o mais rápido possível, senão, cara, assim, não é legal você ter um código que tem 300 milhões de ramificações diferentes, tá? Quanto mais tempo a sua feature flag vive e quanto maior a feature que está por trás da flag, mais isso vira como se fosse um fork da codebase, uma codebase inteira completamente diferente. Eu já vi isso acontecer algumas vezes, é tenebroso. Quando você faz a migração, por exemplo, de v1 está atrás de uma feature flag e v2 está atrás de outra feature flag, Se você não deprecar e deletar esse V1 rapidamente, vai virar um fork permanente no seu código e você vai estar mantendo dois serviços dentro do mesmo código de uma maneira que fica tenebrosa. Claro, algumas feature flags vão viver para sempre mesmo. Por exemplo, se eu trabalho com feature flags e eu tenho a feature flag admin do meu sistema, ok, isso é uma feature flag que vai viver para sempre e é o intuito dela viver para sempre. Se eu tenho uma feature flag, eu já vi esse exato nome muitas vezes. NEW CHECKOUT ou NEW CHECKOUT EXPERIENCE, essa feature flag é uma feature flag que é pra morrer. Quando você migrar 10, 20% dos usuários pro NEW CHECKOUT EXPERIENCE, em algum momento você migra todos e deleta a feature flag. Aí vai ter um cliente que vai reclamar e vai falar, esse novo checkout ficou uma porcaria, eu quero o antigo de volta. E o que você vai responder? Depende do quanto por cento da receita é esse cliente, tá? Se for menos que 10% da receita da sua empresa, você vai responder que não. Ele não pode ter o checkout antigo e ele pode te dar feedback de por que o novo checkout é ruim, mas ele não pode ter o antigo. Porque se você ouvir o seu cliente, você vai ter que... no futuro você vai ouvir outros clientes também e a sua codebase vai virar um fork em cima de um fork em cima de um fork. Cara, de repente você está administrando software personalizado para cada empresa. Eu já vi isso acontecer mais de uma vez. Feature Flags em algum momento viram software personalizado para cada um dos seus clientes. Você não quer que isso aconteça, você tem que aprender a dizer não para os seus clientes. Uma coisa que, assim, cara, é complexo. Feature Flags adicionam complexidade, né? Eu te falei que é um IFELS, IFELS adiciona complexidade, é óbvio, qualquer um que consegue visualizar isso tá vendo que adiciona algum tipo de complexidade. Quando você tem Feature Flag dentro de Feature Flag, quando você tem problemas com nesting, aí o negócio começa a complicar, né? Vamos voltar lá no exemplo. Eu tenho o exemplo do New Checkout, tá? New Checkout, vamos supor que seja uma tela nova de Checkout, os usuários vão ter um front-end diferente para fazer o Checkout. Mas vamos supor que alguns usuários têm acesso a PIX e alguns usuários não têm acesso a PIX. Então aqui, Raspix. Antes a gente tinha duas possíveis telas, Checkout Novo e Checkout Antigo. Agora a gente tem quatro possíveis telas, Checkout Novo, Check-out novo com PIX, Check-out antigo, Check-out antigo com PIX. Adiciona outro aqui. HazCard, tem cartão de crédito. Quantas telas a gente tem agora, quantas possibilidades a gente tem? Oito possibilidades. Debugar isso aqui fica um saco, porque na verdade construir essa tela já fica muito chato, porque às vezes você tem que unir o Check-out e o Old Check-out, são as partes grandes do... São as telas em si, e dentro de cada uma dessas você vai ter que ter um if-else pra se tem pixel ou não, e você vai ter que ter também um if-else pra se tem cartão ou não dentro de cada uma delas. É, o negócio começa a ficar muito doido aqui. Esses são problemas que ocorrem em feature flags, agora tem erros que as pessoas cometem com feature flags, tá? Não é um problema de feature flag per se, é um erro que a pessoa comete, que é não ter fallback, por exemplo. Ou então não pensar no fallback. Se a gente tem o new checkout, eu tenho que ter um fallback. É legal que eu tenha um else porque pode ser que eu esqueça de adequar o comportamento para caso a feature flag não esteja presente. E se eu tiver muitas feature flags, eu provavelmente vou esquecer alguma combinação delas. Isso acontece bastante. Então você tem que ter um default ali que faz alguma coisa. Ou então, às vezes, você não vê todas as ramificações e você não pensa adequadamente em todos os fallbacks e você não se planeja adequadamente. fazer feature flags no client-side, no front-end, por exemplo, ou fazer essa verificação no front-end, de modo que você envia coisas para o usuário que ele não poderia ter acesso, certo? E no front-end você checa se o usuário is admin ou não. Aí, o que parecia uma feature flag, virou uma vulnerabilidade. Tem feature flags que são inconsequentes no front-end. Se você checar se o usuário tem um novo checkout ou checkout antigo no front-end, meio que tanto faz, sabe? Não tem muito problema o usuário conseguir acessar o checkout antigo se ele hackear o seu site. Ninguém vai fazer isso, não faz sentido. Agora, se você enviar informações de administrador para o seu usuário e você checar no front-end, aí é bem vulnerável. Qualquer um que saiba, clicar com o botão direito, clicar em... Cadê? Aqui, em Inspect no site. Vai conseguir ver tudo o que está escondido atrás do .exadmin. Feature Flags são uma ferramenta fantástica. Eu gosto muito do conceito de testar com um percentual pequeno da Codebase para fazer uma integração mais rápida, para poder tomar mais riscos e ter uma kill switch, poder desligar a feature se der errado. Isso aqui eu acho excelente. É muito mais fácil desligar algo que deu errado se estiver por trás de uma Feature Flag do que ter que fazer um rollback. Mas algo que eu sempre vejo acontecer é esse problema aqui, esse que é o principal. Feature Flags viram Forks. Recomendação pra você, se você gostou e quiser testar Feature Flags no seu projeto pessoal, você faz o que você quiser. Se você estiver numa empresa que não utiliza de Feature Flags e você vê que talvez.


[Segment 2 | start=900s]

Existe uma maneira de utilizar, tá? Começa testando com coisas inconsequentes, para você ver se faz sentido ou não, né? Começa com uma solução já pronta, ao invés de querer reinventar a roda e implementar tudo por si mesmo, por conta própria, porque feature flags são um pouco chatinhas de se implementar, tá? De você conseguir... Como é que você implementa, ativar e desativar a feature flag de um usuário? Você não vai ter um dashboard ali das feature flags? Como é que você implementa rolar um negócio para 20, 30, 40 usuários diferentes, sabe? Você vai construir o seu próprio dashboard para fazer isso? Ou você vai fazer operações no SQL? Enfim, podem ser ferramentas fantásticas, caso você use na sua empresa. Faça um esforço contínuo para remover todas as feature flags que viram forks no seu código. Isso se você quiser que sua empresa vá longe, tá? Se você quiser que seja uma empresa longeva, que faz uma plataforma, faz um esforço pra ir removendo as feature flags. Senão você tá basicamente virando uma fábrica de software pra cada empresa, só que todo o software tá na mesma codebase, saca? Fica um negócio muito bizarrinho.

O texto discute o conceito e as utilidades das Feature Flags no desenvolvimento de software, bem como seus desafios e melhores práticas.

---

### Resumo sobre Feature Flags

**I. Introdução às Feature Flags**
*   **A. Definição Básica:** Uma Feature Flag é essencialmente um comando `if-else` no código que executa uma determinada lógica se uma "bandeira" (flag) estiver ativada, controlando o acesso ou comportamento de uma funcionalidade.
    *   Exemplo: `if user.v2_enabled`, executa a versão 2, caso contrário, a versão 1.
*   **B. Funcionamento Simplificado:** Embora a implementação possa ser complexa, a ideia central é verificar um atributo (a flag) associado a um usuário ou grupo para decidir qual caminho de código seguir.
*   **C. Local de Armazenamento/Gerenciamento:** As flags podem ser gerenciadas em bancos de dados ou, mais comumente, por ferramentas especializadas como LaunchDarkly, que oferecem SDKs, UIs e dashboards para configuração por usuário ou grupo.

**II. Principais Utilidades e Vantagens das Feature Flags**
*   **A. Ocultar Funcionalidades Incompletas (Trunk-based Development):** Permite que equipes deployem código inacabado diretamente na branch principal (`main`) sem expor a funcionalidade aos usuários finais, sendo liberada gradualmente.
*   **B. Segmentação de Usuários:** Permite controlar quais usuários ou grupos têm acesso a certas funcionalidades (ex: usuários premium, beta testers, administradores).
*   **C. Testes A/B:** Possibilita testar diferentes versões de uma funcionalidade com diferentes segmentos de usuários para coletar feedback e dados.
*   **D. Lançamento Gradual (Rollout Progressivo):**
    *   **1. Redução de Risco:** Lançar novas funcionalidades para uma pequena porcentagem da base de usuários (ex: 0.1%, 1%, 10%) antes de um rollout completo, minimizando o impacto de possíveis bugs.
    *   **2. Implementação:** Começar com funcionários da empresa, depois para um percentual mínimo de usuários, e escalar se não houver problemas. Inspirado em modelos como o da Meta ("Massive Rollout at Massive Scale").
    *   **3. Capacidade de "Kill Switch":** Se um bug for detectado, a funcionalidade pode ser desativada instantaneamente através da Feature Flag, sem a necessidade de um novo deploy ou rollback, agindo como um "circuit breaker".
*   **E. Separação de Deploy e Release:** Dissocia o momento em que o código é deployado para produção do momento em que a funcionalidade é liberada para os usuários, facilitando a integração contínua.
*   **F. Benefícios Gerais:** Menor impacto nos testes, integração contínua, redução de risco, maior conforto para lançar e experimentar, inovação e agilidade.

**III. Desafios, Problemas e Erros Comuns**
*   **A. Aumento da Complexidade:**
    *   **1. Aninhamento de Flags:** O uso de múltiplas Feature Flags aninhadas (ex: `if new_checkout` e dentro dele `if has_pix`) pode levar a uma explosão combinatória de estados possíveis, tornando o código difícil de construir, testar e debugar.
*   **B. "Feature Flags Viram Forks":**
    *   **1. Manutenção de Múltiplas Versões:** Flags temporárias (ex: `NEW_CHECKOUT_EXPERIENCE`) que permanecem por muito tempo no código transformam-se em "forks" permanentes, exigindo a manutenção de duas ou mais versões da mesma funcionalidade, aumentando a dívida técnica.
    *   **2. Exceções (Flags Permanentes):** Algumas flags (ex: `is_admin`) são intencionalmente permanentes e não se encaixam neste problema.
    *   **3. Impacto na Relação com o Cliente:** A relutância em remover flags antigas (ex: manter um "checkout antigo" a pedido de um cliente específico) pode levar a uma personalização excessiva e insustentável do software.
*   **C. Falta de Fallback:** Não prever o comportamento padrão ou "else" caso uma flag não esteja presente ou uma combinação específica não seja considerada, levando a erros inesperados.
*   **D. Vulnerabilidades de Segurança (Client-side):** Verificar permissões sensíveis (ex: `is_admin`) no frontend (lado do cliente) é um erro grave de segurança, pois usuários podem facilmente inspecionar o código e contornar a verificação. Flags para aspectos visuais ou de UI no frontend são geralmente inofensivas.

**IV. Recomendações e Melhores Práticas**
*   **A. Remoção Oportuna de Flags Temporárias:** Fazer um esforço contínuo para podar e remover Feature Flags que não são mais necessárias, evitando que se tornem "forks" permanentes.
*   **B. Começar com Cautela:** Iniciar o uso de Feature Flags com funcionalidades inconsequentes para que a equipe possa se familiarizar com a ferramenta e seu impacto.
*   **C. Utilizar Soluções Prontas:** Evitar reinventar a roda e optar por ferramentas de terceiros para gerenciamento de Feature Flags, que já oferecem dashboards e funcionalidades complexas.
*   **D. Aprender a Dizer Não a Clientes:** Ser firme na decisão de desativar ou remover funcionalidades antigas, mesmo que alguns clientes prefiram as versões anteriores, para evitar a personalização excessiva do código.

---

### Possíveis Tópicos para Quiz

1.  **Definição:** O que é uma Feature Flag em termos de código?
2.  **Exemplos de Ferramentas:** Cite um exemplo de ferramenta para gerenciar Feature Flags.
3.  **Vantagem Principal:** Qual é o benefício mais significativo do lançamento gradual ("rollout") de funcionalidades com Feature Flags?
4.  **"Kill Switch":** Explique o conceito de "kill switch" no contexto das Feature Flags.
5.  **Separação de Conceitos:** Como as Feature Flags ajudam a separar "deploy" de "release"?
6.  **Desvantagem Crítica:** Qual é a principal desvantagem ou risco de longo prazo associado às Feature Flags?
7.  **"Feature Flags Viram Forks":** O que significa a afirmação "Feature Flags viram forks" e por que isso é um problema?
8.  **Segurança (Client-side):** Por que é perigoso usar Feature Flags para verificar permissões de usuário no frontend?
9.  **Aninhamento de Flags:** Qual o problema do aninhamento excessivo de Feature Flags?
10. **Melhores Práticas:** Cite duas recomendações importantes para o uso eficaz de Feature Flags.
11. **Trunk-based Development:** Como as Feature Flags apoiam o "trunk-based development"?
12. **Tipos de Flags:** Dê um exemplo de uma Feature Flag que pode ser permanente e outra que deve ser temporária.